<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Anatomy Pro | Botox Simulator</title>
    <style>
        :root { --accent: #00ffcc; --danger: #ff3030; --gold: #ffd700; }
        body { margin: 0; background: #0a0a0a; color: white; font-family: 'Segoe UI', Roboto, sans-serif; overflow: hidden; }
        
        .ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; }
        .header { background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 0 0 20px 20px; border: 1px solid var(--accent); pointer-events: auto; text-align: center; }
        .controls { position: fixed; bottom: 30px; display: flex; gap: 15px; pointer-events: auto; }
        
        button { 
            background: rgba(255,255,255,0.1); border: 1px solid var(--accent); color: white; 
            padding: 12px 24px; border-radius: 30px; cursor: pointer; transition: all 0.3s;
            backdrop-filter: blur(10px); font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
        }
        button:hover { background: var(--accent); color: black; box-shadow: 0 0 20px var(--accent); }
        button.active { background: var(--gold); color: black; border-color: var(--gold); }

        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        .alert { color: var(--danger); font-weight: bold; animation: blink 1s infinite; display: none; margin-top: 10px; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div class="ui-overlay">
        <div class="header">
            <div id="status">Ініціалізація AI-моделі...</div>
            <div id="activity-alert" class="alert">ГІПЕРАКТИВНІСТЬ МІЖБРІВ'Я ВИЯВЛЕНО</div>
        </div>
        
        <div class="controls">
            <button id="btn-mesh" class="active">Anatomy Mesh</button>
            <button id="btn-botox">Simulate Botox</button>
        </div>
    </div>

    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const video = document.getElementById("video");
        const canvas = document.getElementById("output_canvas");
        const canvasCtx = canvas.getContext("2d");
        const statusElement = document.getElementById("status");
        const alertElement = document.getElementById("activity-alert");

        let faceLandmarker;
        let lastVideoTime = -1;
        let isBotoxMode = false;
        let isMeshMode = true;

        document.getElementById('btn-mesh').onclick = (e) => { isMeshMode = !isMeshMode; e.target.classList.toggle('active'); };
        document.getElementById('btn-botox').onclick = (e) => { isBotoxMode = !isBotoxMode; e.target.classList.toggle('active'); };

        async function init() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { 
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU" 
                },
                runningMode: "VIDEO", numFaces: 1
            });
            statusElement.innerText = "Система готова до діагностики";
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.addEventListener("loadeddata", renderLoop);
        }

        function renderLoop() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, performance.now());
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];
                    const drawingUtils = new DrawingUtils(canvasCtx);

                    // 1. АНАЛІЗ АКТИВНОСТІ
                    const p1 = landmarks[52]; 
                    const p2 = landmarks[282]; 
                    const distance = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    
                    if (distance < 0.08) { alertElement.style.display = "block"; } 
                    else { alertElement.style.display = "none"; }

                    // 2. ВІЗУАЛІЗАЦІЯ АНАТОМІЇ
                    if (isMeshMode) {
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: "#C0C0C030", lineWidth: 0.5 });
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_FACE_CONTOUR, { color: "#00ffcc", lineWidth: 1 });
                        
                        // Золоті точки (Міжбрів'я)
                        [9, 8, 168].forEach(idx => {
                            const p = landmarks[idx];
                            canvasCtx.fillStyle = "#ffd700";
                            canvasCtx.shadowBlur = 15; canvasCtx.shadowColor = "#ffd700";
                            canvasCtx.beginPath();
                            canvasCtx.arc(p.x * canvas.width, p.y * canvas.height, 5, 0, 2 * Math.PI);
                            canvasCtx.fill();
                        });
                        canvasCtx.shadowBlur = 0;

                        // Діагностичні точки (Гусячі лапки)
                        const eyeZones = [33, 133, 362, 263];
                        eyeZones.forEach(idx => {
                            const p = landmarks[idx];
                            canvasCtx.fillStyle = "rgba(0, 255, 204, 0.5)";
                            canvasCtx.beginPath();
                            canvasCtx.arc(p.x * canvas.width, p.y * canvas.height, 3, 0, 2 * Math.PI);
                            canvasCtx.fill();
                        });
                    }

                    // 3. СИМУЛЯЦІЯ BOTOX
                    if (isBotoxMode) {
                        // Маска на чоло
                        const foreheadPoints = [10, 338, 297, 332, 284, 251, 21, 54, 103, 67, 109];
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(landmarks[10].x * canvas.width, landmarks[10].y * canvas.height);
                        foreheadPoints.forEach(idx => canvasCtx.lineTo(landmarks[idx].x * canvas.width, landmarks[idx].y * canvas.height));
                        canvasCtx.closePath();
                        canvasCtx.fillStyle = "rgba(255, 230, 220, 0.4)";
                        canvasCtx.filter = "blur(10px)";
                        canvasCtx.fill();
                        canvasCtx.filter = "none";

                        // Маски на кути очей
                        [33, 263].forEach(idx => {
                            const p = landmarks[idx];
                            canvasCtx.beginPath();
                            canvasCtx.arc(p.x * canvas.width, p.y * canvas.height, 35, 0, 2 * Math.PI);
                            canvasCtx.fillStyle = "rgba(255, 230, 220, 0.3)";
                            canvasCtx.filter = "blur(15px)";
                            canvasCtx.fill();
                            canvasCtx.filter = "none";
                        });
                    }
                }
            }
            requestAnimationFrame(renderLoop);
        }

        init();
    </script>
</body>
</html>
