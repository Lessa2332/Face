<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Beauty AI ‚Ä¢ –í–∏—Å—É–≤–Ω–∞ –ø–∞–Ω–µ–ª—å</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫–∞–º–µ—Ä–∏ –Ω–∞ –≤–µ—Å—å –µ–∫—Ä–∞–Ω */
        .camera-full {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .mirror {
            transform: scaleX(-1);
        }

        /* –í–µ—Ä—Ö–Ω—è –ø–∞–Ω–µ–ª—å –∫–µ—Ä—É–≤–∞–Ω–Ω—è (–∑–∞–≤–∂–¥–∏ –≤–∏–¥–∏–º–∞) */
        .top-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            z-index: 20;
        }

        .ctrl-btn {
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid #00ffcc;
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: all 0.2s;
        }

        .ctrl-btn.active {
            background: #00ffcc;
            color: black;
        }

        .mode-btn {
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid #00ffcc;
            color: white;
            padding: 8px 16px;
            border-radius: 40px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .mode-btn.active {
            background: #00ffcc;
            color: black;
        }

        /* –Ü–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å—Ç—É–ø–µ–Ω—è –º–µ—Ä—Ü—è (–∑–∞–≤–∂–¥–∏ –≤–∏–¥–∏–º–∏–π) */
        .mertz-indicator {
            position: absolute;
            bottom: 90px; /* –Ω–∞–¥ –ø–∞–Ω–µ–ª–ª—é */
            left: 20px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            border: 2px solid #00ffcc;
            border-radius: 60px;
            padding: 8px 18px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 25;
        }

        .mertz-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .mertz-value {
            font-size: 36px;
            font-weight: 800;
            line-height: 1;
        }

        .alert-badge {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff3030;
            padding: 6px 18px;
            border-radius: 30px;
            font-weight: bold;
            display: none;
            z-index: 30;
            white-space: nowrap;
        }

        /* ===== –í–ò–°–£–í–ù–ê –ù–ò–ñ–ù–Ø –ü–ê–ù–ï–õ–¨ ===== */
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(10px);
            border-top: 2px solid #00ffcc;
            border-radius: 30px 30px 0 0;
            z-index: 100;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(calc(100% - 50px)); /* —Å–ø–æ—á–∞—Ç–∫—É –≤–∏–¥–Ω–æ —Ç—ñ–ª—å–∫–∏ —Ä—É—á–∫—É */
            box-shadow: 0 -10px 30px rgba(0,0,0,0.8);
        }

        .bottom-sheet.open {
            transform: translateY(0); /* –ø–æ–≤–Ω—ñ—Å—Ç—é –≤—ñ–¥–∫—Ä–∏—Ç–∞ */
        }

        /* –†—É—á–∫–∞ –¥–ª—è –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è */
        .sheet-handle {
            width: 100%;
            height: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .handle-bar {
            width: 50px;
            height: 5px;
            background: #00ffcc;
            border-radius: 10px;
            margin-bottom: 5px;
        }

        .handle-text {
            font-size: 12px;
            color: #00ffcc;
            opacity: 0.8;
        }

        /* –ö–æ–Ω—Ç–µ–Ω—Ç –ø–∞–Ω–µ–ª—ñ (—Å–∫—Ä–æ–ª–∏—Ç—å—Å—è) */
        .sheet-content {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* –°—ñ—Ç–∫–∞ –º–µ—Ç—Ä–∏–∫ */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        @media (min-width: 500px) {
            .metrics-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .metric-card {
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid #00ffcc;
            border-radius: 20px;
            padding: 15px 5px;
            text-align: center;
        }

        .metric-card h4 {
            color: #00ffcc;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 22px;
            font-weight: 700;
            color: white;
        }

        .metric-max {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }

        .metric-max span {
            color: #00ffcc;
        }

        /* –ì—Ä–∞—Ñ—ñ–∫ */
        .graph-container {
            background: rgba(0,0,0,0.5);
            border: 1px solid #00ffcc;
            border-radius: 25px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .graph-title {
            color: #00ffcc;
            margin-bottom: 10px;
            font-weight: 600;
        }

        #graphCanvas {
            width: 100%;
            height: auto;
            background: #1e1e1e;
            border-radius: 15px;
        }

        /* –§–æ—Ç–æ –¥–æ/–ø—ñ—Å–ª—è */
        .photo-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .photo-card {
            flex: 1;
            max-width: 150px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #00ffcc;
            border-radius: 20px;
            padding: 12px;
            text-align: center;
        }

        .photo-card img {
            width: 100%;
            aspect-ratio: 4/3;
            object-fit: cover;
            border-radius: 15px;
            background: #2a2a2a;
        }

        .photo-btn {
            margin-top: 10px;
            padding: 8px;
            font-size: 13px;
            background: transparent;
            border: 1px solid #00ffcc;
            color: #00ffcc;
            border-radius: 30px;
            cursor: pointer;
            width: 100%;
        }

        /* –ö–Ω–æ–ø–∫–∏ –¥—ñ–π */
        .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .big-btn {
            background: transparent;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 12px 20px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            flex: 1 1 auto;
            min-width: 140px;
        }

        .big-btn.primary {
            background: #00ffcc;
            color: black;
        }
    </style>
</head>
<body>
    <div class="camera-full">
        <video id="video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>

        <!-- –¢—Ä–∏–≤–æ–≥–∞ –≥—ñ–ø–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ -->
        <div id="alertBadge" class="alert-badge">–ì–Ü–ü–ï–†–ê–ö–¢–ò–í–ù–Ü–°–¢–¨</div>

        <!-- –í–µ—Ä—Ö–Ω—è –ø–∞–Ω–µ–ª—å –∫–µ—Ä—É–≤–∞–Ω–Ω—è -->
        <div class="top-controls">
            <div class="ctrl-btn" id="btnCam" title="–ó–º—ñ–Ω–∏—Ç–∏ –∫–∞–º–µ—Ä—É">üîÑ</div>
            <div class="ctrl-btn" id="btnFreeze" title="–ó–∞–º–æ—Ä–æ–∑–∏—Ç–∏ –∫–∞–¥—Ä">‚ùÑÔ∏è</div>
            <div class="mode-btn" id="btnMesh">üìê –°—ñ—Ç–∫–∞</div>
            <div class="mode-btn" id="btnMimic">üî• –ú—ñ–º—ñ–∫–∞</div>
            <div class="mode-btn" id="btnBotox">üíâ –ë–æ—Ç–æ–∫—Å</div>
        </div>

        <!-- –°—Ç—É–ø—ñ–Ω—å –º–µ—Ä—Ü—è (–∑–∞–≤–∂–¥–∏ –≤–∏–¥–Ω–æ) -->
        <div class="mertz-indicator">
            <span class="mertz-label">–°—Ç—É–ø—ñ–Ω—å –º–µ—Ä—Ü—è</span>
            <span class="mertz-value" id="mertzValue">0</span>
        </div>

        <!-- –ù–ò–ñ–ù–Ø –í–ò–°–£–í–ù–ê –ü–ê–ù–ï–õ–¨ -->
        <div class="bottom-sheet" id="bottomSheet">
            <div class="sheet-handle" id="sheetHandle">
                <div class="handle-bar"></div>
                <div class="handle-text">–ü–æ–∫–∞–∑–Ω–∏–∫–∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ</div>
            </div>
            <div class="sheet-content" id="sheetContent">
                <!-- –°—ñ—Ç–∫–∞ –º–µ—Ç—Ä–∏–∫ (–±—É–¥–µ –∑–∞–ø–æ–≤–Ω–µ–Ω–∞ JS) -->
                <div class="metrics-grid" id="metricsGrid"></div>

                <!-- –ì—Ä–∞—Ñ—ñ–∫ -->
                <div class="graph-container">
                    <div class="graph-title">üìà –î–∏–Ω–∞–º—ñ–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ (60 –∫–∞–¥—Ä—ñ–≤)</div>
                    <canvas id="graphCanvas" width="600" height="150"></canvas>
                </div>

                <!-- –§–æ—Ç–æ –¥–æ/–ø—ñ—Å–ª—è -->
                <div class="photo-row">
                    <div class="photo-card">
                        <img id="photoBefore" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='113' viewBox='0 0 150 113'%3E%3Crect width='150' height='113' fill='%232a2a2a'/%3E%3Ctext x='30' y='60' fill='%2300ffcc' font-size='12'%3E–î–æ%3C/text%3E%3C/svg%3E" alt="Before">
                        <button class="photo-btn" id="photoBeforeBtn">üì∏ –ó—Ä–æ–±–∏—Ç–∏ –î–æ</button>
                    </div>
                    <div class="photo-card">
                        <img id="photoAfter" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='113' viewBox='0 0 150 113'%3E%3Crect width='150' height='113' fill='%232a2a2a'/%3E%3Ctext x='30' y='60' fill='%2300ffcc' font-size='12'%3E–ü—ñ—Å–ª—è%3C/text%3E%3C/svg%3E" alt="After">
                        <button class="photo-btn" id="photoAfterBtn">üì∏ –ó—Ä–æ–±–∏—Ç–∏ –ü—ñ—Å–ª—è</button>
                    </div>
                </div>

                <!-- –ö–Ω–æ–ø–∫–∏ –¥—ñ–π -->
                <div class="actions">
                    <button class="big-btn" id="resetMaxBtn">üîÑ –°–∫–∏–Ω—É—Ç–∏ –º–∞–∫—Å–∏–º—É–º–∏</button>
                    <button class="big-btn primary" id="saveSessionBtn">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —Å–µ—Å—ñ—é</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // ---------- DOM ----------
        const video = document.getElementById('video');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        const mertzSpan = document.getElementById('mertzValue');
        const alertBadge = document.getElementById('alertBadge');
        
        // –ö–Ω–æ–ø–∫–∏
        const btnCam = document.getElementById('btnCam');
        const btnFreeze = document.getElementById('btnFreeze');
        const btnMesh = document.getElementById('btnMesh');
        const btnMimic = document.getElementById('btnMimic');
        const btnBotox = document.getElementById('btnBotox');
        const resetMaxBtn = document.getElementById('resetMaxBtn');
        const saveSessionBtn = document.getElementById('saveSessionBtn');
        const photoBeforeBtn = document.getElementById('photoBeforeBtn');
        const photoAfterBtn = document.getElementById('photoAfterBtn');
        
        // –ù–∏–∂–Ω—è –ø–∞–Ω–µ–ª—å
        const bottomSheet = document.getElementById('bottomSheet');
        const sheetHandle = document.getElementById('sheetHandle');
        
        // –ì—Ä–∞—Ñ—ñ–∫
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        // ---------- –°—Ç–∞–Ω ----------
        let faceLandmarker;
        let isFrontCamera = false;
        let isFrozen = false;
        let meshMode = true;
        let mimicMode = false;
        let botoxMode = false;
        let panelOpen = false; // —á–∏ –≤—ñ–¥–∫—Ä–∏—Ç–∞ –Ω–∏–∂–Ω—è –ø–∞–Ω–µ–ª—å

        // –ö–∞–ª—ñ–±—Ä—É–≤–∞–Ω–Ω—è —Ç–∞ –º–µ—Ç—Ä–∏–∫–∏
        let baseline = {
            eyeDistance: null,
            browLeftY: null, browRightY: null,
            eyeLeftDist: null, eyeRightDist: null,
            mouthLeftY: null, mouthRightY: null
        };
        let shouldCalibrate = true;

        let current = {
            browLeft: 0, browRight: 0,
            eyeLeft: 0, eyeRight: 0,
            mouthLeft: 0, mouthRight: 0
        };

        let maxValues = {
            browLeft: 0, browRight: 0,
            eyeLeft: 0, eyeRight: 0,
            mouthLeft: 0, mouthRight: 0
        };

        const historyLength = 60;
        let history = {
            browLeft: [], browRight: [],
            eyeLeft: [], eyeRight: [],
            mouthLeft: [], mouthRight: []
        };

        const IDX = {
            LEFT_EYE_OUTER: 33, RIGHT_EYE_OUTER: 263,
            LEFT_BROW: 105, RIGHT_BROW: 334,
            LEFT_EYE_UPPER: 34, LEFT_EYE_LOWER: 94,
            RIGHT_EYE_UPPER: 264, RIGHT_EYE_LOWER: 394,
            LEFT_MOUTH: 61, RIGHT_MOUTH: 291
        };

        // ---------- –§—É–Ω–∫—Ü—ñ—ó ----------
        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                    delegate: "GPU"
                },
                outputFaceBlendshapes: true,
                runningMode: "VIDEO",
                numFaces: 1
            });
            startCamera();
            video.addEventListener("loadeddata", renderLoop);
        }

        async function startCamera() {
            if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: isFrontCamera ? "user" : "environment" }
                });
                video.srcObject = stream;
                [video, canvas].forEach(el => {
                    if (isFrontCamera) el.classList.add('mirror');
                    else el.classList.remove('mirror');
                });
            } catch (err) {
                alert('–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏: ' + err.message);
            }
        }

        function renderLoop() {
            if (isFrozen) return requestAnimationFrame(renderLoop);
            if (video.videoWidth && video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                if (faceLandmarker) {
                    const results = faceLandmarker.detectForVideo(video, performance.now());
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                        const landmarks = results.faceLandmarks[0];
                        const shapes = results.faceBlendshapes[0].categories;
                        computeMertz(shapes);
                        updateMetrics(landmarks, shapes);
                        if (meshMode) drawMesh(landmarks);
                        if (mimicMode) drawMimicHeatmap(landmarks, current);
                        if (botoxMode) drawBotox(landmarks);
                        updateUI();
                        addToHistory();
                        drawGraph();
                    } else {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    }
                }
            }
            requestAnimationFrame(renderLoop);
        }

        function computeMertz(shapes) {
            const get = (name) => shapes.find(s => s.categoryName === name)?.score || 0;
            const browUp = get('browInnerUp') * 2;
            const browDown = get('browDownLeft') + get('browDownRight');
            const squint = get('eyeSquintLeft') + get('eyeSquintRight');
            const blink = get('eyeBlinkLeft') + get('eyeBlinkRight');
            const cleanSquint = blink > 0.5 ? 0 : squint;
            let score = Math.min(4, Math.round((browUp + browDown + cleanSquint) * 2.2));
            mertzSpan.innerText = score;
            mertzSpan.style.color = score >= 3 ? '#ff3030' : (score >= 1 ? '#ffd700' : '#00ffcc');
            alertBadge.style.display = score >= 3 ? 'block' : 'none';
        }

        function updateMetrics(landmarks, shapes) {
            const getPoint = (idx) => {
                const p = landmarks[idx];
                return { x: p.x * canvas.width, y: p.y * canvas.height };
            };
            try {
                const leftEyeOuter = getPoint(IDX.LEFT_EYE_OUTER);
                const rightEyeOuter = getPoint(IDX.RIGHT_EYE_OUTER);
                const eyeDist = Math.hypot(rightEyeOuter.x - leftEyeOuter.x, rightEyeOuter.y - leftEyeOuter.y);
                
                const browLeft = getPoint(IDX.LEFT_BROW);
                const browRight = getPoint(IDX.RIGHT_BROW);
                const leftEyeUpper = getPoint(IDX.LEFT_EYE_UPPER);
                const leftEyeLower = getPoint(IDX.LEFT_EYE_LOWER);
                const rightEyeUpper = getPoint(IDX.RIGHT_EYE_UPPER);
                const rightEyeLower = getPoint(IDX.RIGHT_EYE_LOWER);
                const mouthLeft = getPoint(IDX.LEFT_MOUTH);
                const mouthRight = getPoint(IDX.RIGHT_MOUTH);
                
                if (shouldCalibrate && eyeDist > 0) {
                    baseline.eyeDistance = eyeDist;
                    baseline.browLeftY = browLeft.y;
                    baseline.browRightY = browRight.y;
                    baseline.eyeLeftDist = Math.hypot(leftEyeUpper.x - leftEyeLower.x, leftEyeUpper.y - leftEyeLower.y);
                    baseline.eyeRightDist = Math.hypot(rightEyeUpper.x - rightEyeLower.x, rightEyeUpper.y - rightEyeLower.y);
                    baseline.mouthLeftY = mouthLeft.y;
                    baseline.mouthRightY = mouthRight.y;
                    shouldCalibrate = false;
                    resetMax();
                }
                
                if (baseline.eyeDistance && baseline.eyeDistance > 0) {
                    const norm = baseline.eyeDistance;
                    current.browLeft = Math.max(0, (baseline.browLeftY - browLeft.y) / norm);
                    current.browRight = Math.max(0, (baseline.browRightY - browRight.y) / norm);
                    
                    const eyeLeftDist = Math.hypot(leftEyeUpper.x - leftEyeLower.x, leftEyeUpper.y - leftEyeLower.y);
                    const eyeRightDist = Math.hypot(rightEyeUpper.x - rightEyeLower.x, rightEyeUpper.y - rightEyeLower.y);
                    
                    const blinkLeft = shapes.find(s => s.categoryName === 'eyeBlinkLeft')?.score || 0;
                    const blinkRight = shapes.find(s => s.categoryName === 'eyeBlinkRight')?.score || 0;
                    
                    current.eyeLeft = blinkLeft > 0.5 ? 0 : Math.max(0, (baseline.eyeLeftDist - eyeLeftDist) / norm);
                    current.eyeRight = blinkRight > 0.5 ? 0 : Math.max(0, (baseline.eyeRightDist - eyeRightDist) / norm);
                    
                    current.mouthLeft = Math.max(0, (baseline.mouthLeftY - mouthLeft.y) / norm);
                    current.mouthRight = Math.max(0, (baseline.mouthRightY - mouthRight.y) / norm);
                    
                    for (let key in current) {
                        if (current[key] > maxValues[key]) maxValues[key] = current[key];
                    }
                }
            } catch (e) {}
        }

        function resetMax() {
            for (let key in maxValues) maxValues[key] = 0;
        }

        function updateUI() {
            // –°—Ç–≤–æ—Ä—é—î–º–æ –∫–∞—Ä—Ç–∫–∏, —è–∫—â–æ —Ç—Ä–µ–±–∞
            const grid = document.getElementById('metricsGrid');
            if (grid.children.length === 0) {
                const names = {
                    browLeft: '–õ—ñ–≤–∞ –±—Ä–æ–≤–∞', browRight: '–ü—Ä–∞–≤–∞ –±—Ä–æ–≤–∞',
                    eyeLeft: '–û–∫–æ (–ª—ñ–≤–µ)', eyeRight: '–û–∫–æ (–ø—Ä–∞–≤–µ)',
                    mouthLeft: '–ö—É—Ç–æ–∫ —Ä–æ—Ç–∞ (–ª)', mouthRight: '–ö—É—Ç–æ–∫ —Ä–æ—Ç–∞ (–ø—Ä)'
                };
                let html = '';
                for (let key in names) {
                    html += `
                        <div class="metric-card" id="card_${key}">
                            <h4>${names[key]}</h4>
                            <div class="metric-value" id="val_${key}">0.000</div>
                            <div class="metric-max">–º–∞–∫—Å <span id="max_${key}">0.000</span></div>
                        </div>
                    `;
                }
                grid.innerHTML = html;
            }
            // –û–Ω–æ–≤–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è
            for (let key in current) {
                const valEl = document.getElementById(`val_${key}`);
                const maxEl = document.getElementById(`max_${key}`);
                if (valEl) valEl.innerText = current[key].toFixed(3);
                if (maxEl) maxEl.innerText = maxValues[key].toFixed(3);
            }
        }

        function addToHistory() {
            for (let key in history) {
                history[key].push(current[key]);
                if (history[key].length > historyLength) history[key].shift();
            }
        }

        function drawGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            let maxVal = 0.05;
            for (let key in history) {
                const arr = history[key];
                if (arr.length > 0) {
                    const m = Math.max(...arr);
                    if (m > maxVal) maxVal = m;
                }
            }
            if (maxVal < 0.01) maxVal = 0.01;
            const w = graphCanvas.width, h = graphCanvas.height, xStep = w / (historyLength - 1);
            const colors = {
                browLeft: '#00ffcc', browRight: '#ffd700',
                eyeLeft: '#ff7d00', eyeRight: '#ffaa00',
                mouthLeft: '#cbaacb', mouthRight: '#aaccdd'
            };
            for (let key in history) {
                const arr = history[key];
                if (arr.length < 2) continue;
                graphCtx.beginPath();
                graphCtx.strokeStyle = colors[key] || '#fff';
                graphCtx.lineWidth = 2;
                for (let i = 0; i < arr.length; i++) {
                    const x = i * xStep;
                    const y = h - (arr[i] / maxVal) * h * 0.9;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            }
        }

        function drawMesh(landmarks) {
            new DrawingUtils(ctx).drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: '#ffffff20', lineWidth: 0.8 });
        }

        function drawMimicHeatmap(landmarks, cur) {
            const points = [
                { idx: IDX.LEFT_BROW, val: cur.browLeft },
                { idx: IDX.RIGHT_BROW, val: cur.browRight },
                { idx: IDX.LEFT_EYE_UPPER, val: cur.eyeLeft },
                { idx: IDX.RIGHT_EYE_UPPER, val: cur.eyeRight },
                { idx: IDX.LEFT_MOUTH, val: cur.mouthLeft },
                { idx: IDX.RIGHT_MOUTH, val: cur.mouthRight }
            ];
            points.forEach(p => {
                if (p.val < 0.01) return;
                const pt = landmarks[p.idx];
                const x = pt.x * canvas.width;
                const y = pt.y * canvas.height;
                const intensity = Math.min(0.8, p.val * 10);
                ctx.shadowBlur = 20;
                ctx.shadowColor = p.val > 0.2 ? '#ff3030' : '#00ffcc';
                ctx.beginPath();
                ctx.arc(x, y, 12 + p.val * 80, 0, Math.PI * 2);
                ctx.fillStyle = p.val > 0.2 ? `rgba(255,48,48,${intensity})` : `rgba(0,255,204,${intensity})`;
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function drawBotox(landmarks) {
            ctx.save();
            ctx.filter = 'blur(15px) brightness(1.1)';
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.beginPath();
            const area = [10, 338, 297, 332, 284, 251, 21, 54, 103, 67];
            for (let i = 0; i < area.length; i++) {
                const p = landmarks[area[i]];
                if (i === 0) ctx.moveTo(p.x * canvas.width, p.y * canvas.height);
                else ctx.lineTo(p.x * canvas.width, p.y * canvas.height);
            }
            ctx.fill();
            ctx.restore();
        }

        function takePhoto(target) {
            const dataURL = canvas.toDataURL('image/png');
            if (target === 'before') document.getElementById('photoBefore').src = dataURL;
            else document.getElementById('photoAfter').src = dataURL;
        }

        function saveSession() {
            const session = {
                timestamp: new Date().toISOString(),
                maxValues: { ...maxValues },
                mertz: mertzSpan.innerText
            };
            let sessions = JSON.parse(localStorage.getItem('beauty_sessions') || '[]');
            sessions.push(session);
            localStorage.setItem('beauty_sessions', JSON.stringify(sessions));
            alert('‚úÖ –°–µ—Å—ñ—é –∑–±–µ—Ä–µ–∂–µ–Ω–æ');
        }

        // ---------- –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø–∞–Ω–µ–ª–ª—é ----------
        function togglePanel() {
            panelOpen = !panelOpen;
            if (panelOpen) bottomSheet.classList.add('open');
            else bottomSheet.classList.remove('open');
        }

        sheetHandle.addEventListener('click', togglePanel);

        // ---------- –Ü–Ω—à—ñ –æ–±—Ä–æ–±–Ω–∏–∫–∏ ----------
        btnCam.addEventListener('click', () => { isFrontCamera = !isFrontCamera; startCamera(); });
        btnFreeze.addEventListener('click', () => { isFrozen = !isFrozen; btnFreeze.classList.toggle('active'); });
        btnMesh.addEventListener('click', () => { meshMode = !meshMode; btnMesh.classList.toggle('active'); });
        btnMimic.addEventListener('click', () => { mimicMode = !mimicMode; btnMimic.classList.toggle('active'); });
        btnBotox.addEventListener('click', () => { botoxMode = !botoxMode; btnBotox.classList.toggle('active'); });
        resetMaxBtn.addEventListener('click', resetMax);
        saveSessionBtn.addEventListener('click', saveSession);
        photoBeforeBtn.addEventListener('click', () => takePhoto('before'));
        photoAfterBtn.addEventListener('click', () => takePhoto('after'));

        // ---------- –°—Ç–∞—Ä—Ç ----------
        initAI();
    </script>
</body>
</html>
