<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Beauty | AI Facial Anatomy Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --accent: #00ffcc; --danger: #ff3030; --gold: #ffd700; --panel-bg: rgba(10, 10, 10, 0.9); }
        body { margin: 0; background: #000; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        .ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .brand-header {
            position: absolute; top: 20px; left: 20px; display: flex; align-items: center; gap: 15px;
            background: var(--panel-bg); padding: 10px 20px; border-radius: 50px; border: 1px solid var(--accent); pointer-events: auto;
        }
        .brand-logo { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; border: 2px solid var(--accent); }
        .brand-name { font-weight: bold; letter-spacing: 1px; color: var(--accent); text-transform: uppercase; font-size: 0.9rem; }

        .side-panel { 
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%); 
            background: var(--panel-bg); padding: 25px; border-radius: 25px; 
            border: 1px solid rgba(0, 255, 204, 0.3); pointer-events: auto; width: 240px;
            backdrop-filter: blur(15px);
        }

        .lang-btn { position: absolute; top: 20px; right: 20px; background: var(--panel-bg); border: 1px solid var(--accent); color: white; padding: 8px 15px; border-radius: 20px; cursor: pointer; pointer-events: auto; transition: 0.3s; }

        .control-group { margin-bottom: 20px; }
        .group-title { font-size: 0.65rem; text-transform: uppercase; color: var(--accent); opacity: 0.8; margin-bottom: 10px; display: block; letter-spacing: 2px; }
        
        button.action-btn { 
            background: rgba(255,255,255,0.05); border: 1px solid rgba(0, 255, 204, 0.2); color: white; 
            padding: 12px 15px; border-radius: 12px; cursor: pointer; transition: 0.3s;
            width: 100%; text-align: left; font-size: 0.85rem; margin-bottom: 6px; display: flex; justify-content: space-between;
        }
        button.action-btn.active { background: var(--accent); color: black; font-weight: bold; border-color: var(--accent); }
        button.special-btn { border-color: var(--gold); color: var(--gold); }
        button.special-btn.active { background: var(--gold); color: black; }
        button.capture-btn { border-color: #fff; color: #fff; margin-top: 10px; background: rgba(255,255,255,0.1); justify-content: center; }

        .mertz-card { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 15px; text-align: center; }
        .mertz-val { font-size: 2.2rem; font-weight: bold; line-height: 1; transition: 0.3s; }
        
        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        .alert-toast { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); color: var(--danger); font-weight: bold; background: rgba(255,48,48,0.2); padding: 5px 20px; border-radius: 20px; display: none; border: 1px solid var(--danger); text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>

    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <div class="ui-overlay">
        <div class="brand-header">
            <img src="logo-museum.jpg" alt="Smart Beauty" class="brand-logo">
            <span class="brand-name">Smart Beauty AI</span>
        </div>

        <button id="btn-lang" class="lang-btn">EN / UA</button>
        <div id="activity-alert" class="alert-toast">HYPERACTIVITY</div>

        <div class="side-panel">
            <div class="control-group">
                <span class="group-title" id="txt-diag-title">Diagnostics</span>
                <div class="mertz-card">
                    <div class="mertz-val" id="mertz-display">0</div>
                    <div id="txt-mertz-lbl" style="font-size: 0.7rem; margin-top: 5px; opacity: 0.6;">Mertz Scale</div>
                </div>
                <button id="btn-capture" class="action-btn capture-btn">üì∏ <span id="txt-capture">Capture Report</span></button>
            </div>

            <div class="control-group">
                <span class="group-title" id="txt-zones-title">Analysis Zones</span>
                <button id="btn-glabella" class="action-btn active">Glabella</button>
                <button id="btn-frontalis" class="action-btn">Frontalis</button>
                <button id="btn-eyes" class="action-btn">Crow's Feet</button>
                <button id="btn-symmetry" class="action-btn">‚öñÔ∏è <span id="txt-sym">Symmetry</span></button>
            </div>

            <div class="control-group">
                <span class="group-title" id="txt-view-title">Visualization</span>
                <button id="btn-mesh" class="action-btn active">Anatomy Mesh</button>
                <button id="btn-safety" class="action-btn">Risk Zones</button>
                <button id="btn-botox" class="action-btn special-btn">Simulate Botox</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const translations = {
            en: { diag: "Diagnostics", zones: "Analysis Zones", view: "Visualization", mertz: "Mertz Scale", alert: "HYPERACTIVITY", mesh: "Anatomy Mesh", safety: "Risk Zones", botox: "Simulate Botox", glabella: "Glabella", frontalis: "Frontalis", eyes: "Crow's Feet", capture: "Capture Report", sym: "Symmetry" },
            ua: { diag: "–î—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞", zones: "–ó–æ–Ω–∏ –∞–Ω–∞–ª—ñ–∑—É", view: "–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è", mertz: "–®–∫–∞–ª–∞ –ú–µ—Ä—Ü–∞", alert: "–ì–Ü–ü–ï–†–ê–ö–¢–ò–í–ù–Ü–°–¢–¨", mesh: "–ê–Ω–∞—Ç–æ–º—ñ—á–Ω–∞ —Å—ñ—Ç–∫–∞", safety: "–ó–æ–Ω–∏ —Ä–∏–∑–∏–∫—É", botox: "–ï—Ñ–µ–∫—Ç –ë–æ—Ç–æ–∫—Å—É", glabella: "–ú—ñ–∂–±—Ä—ñ–≤'—è", frontalis: "–ß–æ–ª–æ", eyes: "–ì—É—Å—è—á—ñ –ª–∞–ø–∫–∏", capture: "–ó–±–µ—Ä–µ–≥—Ç–∏ –∑–≤—ñ—Ç", sym: "–°–∏–º–µ—Ç—Ä—ñ—è" }
        };
        let lang = 'en';

        const canvas = document.getElementById("output_canvas");
        const canvasCtx = canvas.getContext("2d");
        const video = document.getElementById("video");
        let faceLandmarker, lastVideoTime = -1, smoothedLandmarks = null;
        const lerpFactor = 0.25;

        let states = { glabella: true, frontalis: false, eyes: false, mesh: true, safety: false, botox: false, symmetry: false };

        // UI Handlers
        document.getElementById('btn-lang').onclick = () => {
            lang = lang === 'en' ? 'ua' : 'en';
            const t = translations[lang];
            Object.keys(t).forEach(key => {
                const el = document.getElementById('txt-' + key) || document.getElementById('btn-' + key);
                if (el) el.innerText = t[key];
            });
            document.getElementById('activity-alert').innerText = t.alert;
            document.getElementById('txt-mertz-lbl').innerText = t.mertz;
        };

        const toggleState = (id, key) => {
            document.getElementById(id).onclick = (e) => {
                states[key] = !states[key];
                e.target.closest('button').classList.toggle('active');
            };
        };
        ['glabella', 'frontalis', 'eyes', 'mesh', 'safety', 'botox', 'symmetry'].forEach(k => toggleState('btn-' + k, k));

        // CAPTURE REPORT
        document.getElementById('btn-capture').onclick = () => {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
            tempCtx.save(); tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, -tempCanvas.width, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.fillStyle = "white"; tempCtx.font = "bold 24px Arial";
            tempCtx.fillText(`SMART BEAUTY REPORT | Mertz: ${document.getElementById('mertz-display').innerText}`, 40, 50);
            tempCtx.font = "18px Arial"; tempCtx.fillText(new Date().toLocaleString(), 40, 80);
            const link = document.createElement('a');
            link.download = `Report_${Date.now()}.png`;
            link.href = tempCanvas.toDataURL(); link.click();
        };

        async function init() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numFaces: 1
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = stream;
            video.addEventListener("loadeddata", renderLoop);
        }

        function lerpPoints(newPoints) {
            if (!smoothedLandmarks) return smoothedLandmarks = newPoints;
            return smoothedLandmarks = newPoints.map((p, i) => ({
                x: smoothedLandmarks[i].x + (p.x - smoothedLandmarks[i].x) * lerpFactor,
                y: smoothedLandmarks[i].y + (p.y - smoothedLandmarks[i].y) * lerpFactor,
                z: smoothedLandmarks[i].z + (p.z - smoothedLandmarks[i].z) * lerpFactor
            }));
        }

        function renderLoop() {
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, performance.now());
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = lerpPoints(results.faceLandmarks[0]);
                    const draw = new DrawingUtils(canvasCtx);
                    
                    // --- 1. DYNAMIC MERTZ CALCULATION ---
                    const dist = Math.hypot(landmarks[52].x - landmarks[282].x, landmarks[52].y - landmarks[282].y);
                    let m = 0;
                    if (dist < 0.08) m = 1; if (dist < 0.07) m = 2; if (dist < 0.06) m = 3; if (dist < 0.05) m = 4;
                    
                    const mertzEl = document.getElementById('mertz-display');
                    mertzEl.innerText = m;
                    mertzEl.style.color = m > 2 ? 'var(--danger)' : (m > 0 ? 'var(--gold)' : 'var(--accent)');
                    document.getElementById('activity-alert').style.display = m >= 3 ? 'block' : 'none';

                    // --- 2. LAYERS ---
                    if (states.mesh) draw.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: "#ffffff10", lineWidth: 0.5 });
                    
                    if (states.symmetry) {
                        canvasCtx.strokeStyle = "rgba(0, 255, 204, 0.4)"; canvasCtx.setLineDash([10, 5]);
                        canvasCtx.beginPath(); canvasCtx.moveTo(landmarks[10].x * canvas.width, 0);
                        canvasCtx.lineTo(landmarks[152].x * canvas.width, canvas.height); canvasCtx.stroke(); canvasCtx.setLineDash([]);
                    }

                    // --- 3. DYNAMIC GLABELLA (Color & Pulse) ---
                    if (states.glabella) {
                        let color = m >= 3 ? "#ff3030" : (m >= 1 ? "#ffd700" : "#00ffcc");
                        let pulse = m >= 3 ? Math.sin(Date.now() / 100) * 5 : 0;
                        [9, 8, 168].forEach(i => {
                            canvasCtx.shadowBlur = m * 5; canvasCtx.shadowColor = color;
                            canvasCtx.fillStyle = color; canvasCtx.beginPath();
                            canvasCtx.arc(landmarks[i].x * canvas.width, landmarks[i].y * canvas.height, 4 + m + pulse, 0, 7);
                            canvasCtx.fill();
                        });
                        canvasCtx.shadowBlur = 0;
                    }

                    // --- 4. DOUBLE-SIDED RISK ZONES ---
                    if (states.safety) {
                        canvasCtx.strokeStyle = "red"; canvasCtx.lineWidth = 1.5; canvasCtx.setLineDash([5, 5]);
                        const leftArt = [123, 116, 209, 197, 6];
                        const rightArt = [352, 345, 429, 197, 6];
                        
                        [leftArt, rightArt].forEach(path => {
                            canvasCtx.beginPath();
                            canvasCtx.moveTo(landmarks[path[0]].x * canvas.width, landmarks[path[0]].y * canvas.height);
                            path.forEach(i => canvasCtx.lineTo(landmarks[i].x * canvas.width, landmarks[i].y * canvas.height));
                            canvasCtx.stroke();
                        });
                        canvasCtx.setLineDash([]);
                    }

                    // --- 5. BOTOX SIMULATION (Improved) ---
                    if (states.botox) {
                        canvasCtx.save();
                        canvasCtx.filter = "blur(15px) brightness(1.1)";
                        canvasCtx.fillStyle = "rgba(255, 240, 230, 0.5)";
                        const forehead = [10, 338, 297, 332, 284, 251, 21, 54, 103, 67, 10];
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(landmarks[10].x * canvas.width, landmarks[10].y * canvas.height);
                        forehead.forEach(i => canvasCtx.lineTo(landmarks[i].x * canvas.width, landmarks[i].y * canvas.height));
                        canvasCtx.fill();
                        canvasCtx.restore();
                    }
                }
            }
            requestAnimationFrame(renderLoop);
        }
        init();
    </script>
</body>
</html>
