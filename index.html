<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Anatomy Pro | Expert Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --accent: #00ffcc; --danger: #ff3030; --gold: #ffd700; }
        body { margin: 0; background: #000; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        .ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; }
        .header { background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 0 0 20px 20px; border: 1px solid var(--accent); pointer-events: auto; min-width: 300px; text-align: center; }
        
        .mertz-box { position: fixed; left: 20px; top: 100px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 15px; border-left: 5px solid var(--accent); pointer-events: auto; }
        .controls { position: fixed; bottom: 30px; display: flex; gap: 15px; pointer-events: auto; }
        
        button { 
            background: rgba(255,255,255,0.1); border: 1px solid var(--accent); color: white; 
            padding: 12px 24px; border-radius: 30px; cursor: pointer; transition: 0.3s;
            backdrop-filter: blur(10px); font-weight: bold;
        }
        button.active { background: var(--accent); color: black; }
        button#btn-botox.active { background: var(--gold); }

        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        .alert { color: var(--danger); font-weight: bold; animation: blink 1s infinite; margin-top: 5px; display: none; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div class="ui-overlay">
        <div class="header">
            <div id="status">Завантаження AI-експерта...</div>
            <div id="activity-alert" class="alert">ГІПЕРАКТИВНІСТЬ М’ЯЗІВ</div>
        </div>

        <div class="mertz-box">
            <div style="font-size: 0.8rem; opacity: 0.7;">Діагностика за Мерцом:</div>
            <div id="mertz-value" style="font-size: 2rem; font-weight: bold; color: var(--accent);">0</div>
        </div>
        
        <div class="controls">
            <button id="btn-mesh" class="active">Анатомія</button>
            <button id="btn-safety">Зони ризику</button>
            <button id="btn-botox">Simulate Botox</button>
        </div>
    </div>

    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const video = document.getElementById("video");
        const canvas = document.getElementById("output_canvas");
        const canvasCtx = canvas.getContext("2d");
        const mertzElement = document.getElementById("mertz-value");
        const alertElement = document.getElementById("activity-alert");

        let faceLandmarker;
        let lastVideoTime = -1;
        let isBotoxMode = false;
        let isMeshMode = true;
        let isSafetyMode = false;

        // Three.js змінні
        let scene, camera3D, renderer, muscleMesh;

        // UI Listeners
        document.getElementById('btn-mesh').onclick = (e) => { isMeshMode = !isMeshMode; e.target.classList.toggle('active'); };
        document.getElementById('btn-botox').onclick = (e) => { isBotoxMode = !isBotoxMode; e.target.classList.toggle('active'); };
        document.getElementById('btn-safety').onclick = (e) => { isSafetyMode = !isSafetyMode; e.target.classList.toggle('active'); };

        async function init() {
            // Ініціалізація Three.js
            scene = new THREE.Scene();
            camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            
            const geometry = new THREE.SphereGeometry(0.1, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0xaa0000, transparent: true, opacity: 0.6, shininess: 80 });
            muscleMesh = new THREE.Mesh(geometry, material);
            scene.add(muscleMesh);
            
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 0, 1);
            scene.add(light);
            camera3D.position.z = 2;

            // Ініціалізація MediaPipe
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numFaces: 1
            });
            
            document.getElementById("status").innerText = "Expert System Active";
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.addEventListener("loadeddata", renderLoop);
        }

        function renderLoop() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, performance.now());
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];
                    const drawingUtils = new DrawingUtils(canvasCtx);

                    // 1. РОЗРАХУНОК ШКАЛИ МЕРЦА
                    const p1 = landmarks[52]; 
                    const p2 = landmarks[282]; 
                    const distance = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    
                    let mertzScale = 0;
                    if (distance < 0.09) mertzScale = 1;
                    if (distance < 0.08) mertzScale = 2;
                    if (distance < 0.07) mertzScale = 3;
                    if (distance < 0.06) mertzScale = 4;
                    
                    mertzElement.innerText = mertzScale;
                    mertzElement.style.color = mertzScale > 2 ? "#ff3030" : "#00ffcc";
                    alertElement.style.display = mertzScale >= 2 ? "block" : "none";

                    // 2. ВІЗУАЛІЗАЦІЯ АНАТОМІЇ
                    if (isMeshMode) {
                        drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: "#C0C0C020", lineWidth: 0.5 });
                        
                        // Золоті точки (Glabella)
                        [9, 8, 168].forEach(idx => {
                            const p = landmarks[idx];
                            canvasCtx.fillStyle = "#ffd700";
                            canvasCtx.beginPath();
                            canvasCtx.arc(p.x * canvas.width, p.y * canvas.height, 5, 0, 2 * Math.PI);
                            canvasCtx.fill();
                        });

                        // 3D М'яз (Оновлення позиції)
                        const center = landmarks[9];
                        muscleMesh.position.x = -(center.x - 0.5) * 3; // Інверсія для дзеркала
                        muscleMesh.position.y = -(center.y - 0.5) * 2;
                        muscleMesh.scale.set(1, 0.5 + (mertzScale * 0.2), 1); // "Надування" м'яза
                    }

                    // 3. КАРТА НЕБЕЗПЕЧНИХ ЗОН
                    if (isSafetyMode) {
                        canvasCtx.lineWidth = 2;
                        canvasCtx.strokeStyle = "rgba(255, 0, 0, 0.6)";
                        canvasCtx.setLineDash([5, 5]);
                        const angularArteryPoints = [123, 116, 209, 197, 6]; 
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(landmarks[123].x * canvas.width, landmarks[123].y * canvas.height);
                        angularArteryPoints.forEach(idx => canvasCtx.lineTo(landmarks[idx].x * canvas.width, landmarks[idx].y * canvas.height));
                        canvasCtx.stroke();
                        canvasCtx.setLineDash([]);
                        canvasCtx.fillStyle = "#ff3030";
                        canvasCtx.fillText("DANGER: A. ANGULARIS", landmarks[197].x * canvas.width + 10, landmarks[197].y * canvas.height);
                    }

                    // 4. СИМУЛЯЦІЯ BOTOX
                    if (isBotoxMode) {
                        const foreheadPoints = [10, 338, 297, 332, 284, 251, 21, 54, 103, 67, 109];
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(landmarks[10].x * canvas.width, landmarks[10].y * canvas.height);
                        foreheadPoints.forEach(idx => canvasCtx.lineTo(landmarks[idx].x * canvas.width, landmarks[idx].y * canvas.height));
                        canvasCtx.fillStyle = "rgba(255, 230, 220, 0.4)";
                        canvasCtx.filter = "blur(12px)";
                        canvasCtx.fill();
                        canvasCtx.filter = "none";
                    }
                }
                renderer.render(scene, camera3D);
            }
            requestAnimationFrame(renderLoop);
        }
        init();
    </script>
</body>
</html>
