<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–°–ø—Ä–∞–≤–∂–Ω—ñ–π –º–µ—Ç–µ–æ—Ä–æ–ª–æ–≥: –∑–±–∏—Ä–∞—á –¥–æ—â—É</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0a1a2a; font-family: 'Segoe UI', Roboto, sans-serif; }
        #input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; transform: scaleX(-1); } /* –î–∑–µ—Ä–∫–∞–ª—å–Ω–æ –¥–ª—è –∑—Ä—É—á–Ω–æ—Å—Ç—ñ */
        canvas { position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none; }
        
        #ui-layer { 
            position: absolute; top: 20px; left: 20px; color: #e0f2fe; z-index: 10; 
            background: rgba(10, 30, 50, 0.8); padding: 20px; border-radius: 24px;
            border-left: 6px solid #ffb74d; backdrop-filter: blur(8px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            pointer-events: none;
            border: 1px solid #64b5f6;
        }
        .stat-title { font-size: 14px; opacity: 0.8; letter-spacing: 1px; margin-bottom: 8px; color: #bbdefb; }
        .stats { font-size: 36px; font-weight: 800; color: #ffb74d; line-height: 1; text-shadow: 0 0 15px #ff9800; }
        .stats small { font-size: 16px; color: #90caf9; margin-left: 5px; font-weight: 300; }
        #timer { font-size: 32px; font-weight: 700; color: #64b5f6; margin-top: 10px; }
        #timer.warning { color: #ff7043; }
        .hint { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,20,40,0.8); color: #b3e5fc; padding: 12px 24px; 
            border-radius: 60px; font-size: 18px; backdrop-filter: blur(4px);
            border: 1px solid #ffb74d; z-index: 10; white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background: linear-gradient(145deg, #0b2b40, #071e2c); z-index: 100;
        }
        .btn { 
            padding: 20px 60px; border: 3px solid #ffb74d; background: rgba(255,180,77,0.1); 
            color: #ffb74d; border-radius: 60px; cursor: pointer; font-weight: bold;
            transition: 0.3s; font-size: 28px; letter-spacing: 2px; backdrop-filter: blur(5px);
            box-shadow: 0 0 30px #ffb74d55;
        }
        .btn:hover { background: #ffb74d; color: #0a1a2a; transform: scale(1.05); }
    </style>
</head>
<body>

    <div id="overlay">
        <button class="btn" onclick="startGame()">üå¶Ô∏è –†–û–ó–ü–û–ß–ê–¢–ò</button>
    </div>

    <div id="ui-layer">
        <div class="stat-title">–ó–Ü–ë–†–ê–ù–û –ö–†–ê–ü–ï–õ–¨</div>
        <div class="stats" id="collected">0 <small>/ 60 —Å–µ–∫</small></div>
        <div class="stat-title" style="margin-top: 12px;">–ß–ê–°</div>
        <div id="timer">1:00</div>
    </div>

    <div class="hint" id="hint">üëÜ –¢—Ä–∏–º–∞–π—Ç–µ –¥–æ–ª–æ–Ω—é –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ. –õ–æ–≤—ñ—Ç—å –∫—Ä–∞–ø–ª—ñ –¥–æ—â–æ–º—ñ—Ä–æ–º –∞–±–æ –≤—ñ–¥–±–∏–≤–∞–π—Ç–µ —Ä—É–∫–æ—é!</div>

    <video id="input_video" autoplay playsinline muted></video>

    <script>
        // --- –û—Ç—Ä–∏–º–∞–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ ---
        const videoElement = document.getElementById('input_video');
        const collectedSpan = document.getElementById('collected');
        const timerDiv = document.getElementById('timer');
        const overlay = document.getElementById('overlay');

        // --- –°—Ç–∞–Ω –≥—Ä–∏ ---
        let collectedDrops = 0;
        let timeLeft = 60; // —Å–µ–∫—É–Ω–¥
        let gameActive = false;
        let lastTimestamp = 0;
        let gameInterval = null;

        // --- –¢—Ä–∏–≤–∏–º—ñ—Ä–Ω–∞ —Å—Ü–µ–Ω–∞ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1a2a); // –¢–µ–º–Ω–æ-—Å–∏–Ω—î –Ω–µ–±–æ
        scene.fog = new THREE.Fog(0x0a1a2a, 15, 30);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // –î–ª—è –º–∞–π–±—É—Ç–Ω—å–æ–≥–æ
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambient = new THREE.AmbientLight(0x404060);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 10;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 2;
        dirLight.shadow.camera.far = 20;
        scene.add(dirLight);

        const backLight = new THREE.PointLight(0x4466aa, 0.8);
        backLight.position.set(-3, 4, -5);
        scene.add(backLight);

        // --- –°–¢–í–û–†–ï–ù–ù–Ø –î–û–©–û–ú–Ü–†–ê (–ø–æ–∫—Ä–∞—â–µ–Ω–∏–π) ---
        const gaugeGroup = new THREE.Group();
        scene.add(gaugeGroup);

        // –ó–æ–≤–Ω—ñ—à–Ω—è –∫–æ–ª–±–∞ (—Å–∫–ª–æ) –∑ –ª—ñ–π–∫–æ—é –∑–≤–µ—Ä—Ö—É
        const glassGeo = new THREE.CylinderGeometry(0.45, 0.45, 1.6, 32);
        const glassMat = new THREE.MeshPhongMaterial({ 
            color: 0xd0e4ff, transparent: true, opacity: 0.25, side: THREE.DoubleSide, shininess: 90 
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.castShadow = true;
        glass.receiveShadow = true;
        glass.position.y = 0;
        gaugeGroup.add(glass);

        // –õ—ñ–π–∫–∞ (–≤–æ—Ä–æ–Ω–∫–∞)
        const funnelGeo = new THREE.ConeGeometry(0.6, 0.4, 32);
        const funnelMat = new THREE.MeshPhongMaterial({ color: 0xaaccff, emissive: 0x112233, transparent: true, opacity: 0.6 });
        const funnel = new THREE.Mesh(funnelGeo, funnelMat);
        funnel.position.y = 0.9;
        funnel.castShadow = true;
        gaugeGroup.add(funnel);

        // –í–æ–¥–∞ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ (—Ä—ñ–≤–µ–Ω—å –∑–º—ñ–Ω—é—î—Ç—å—Å—è)
        const waterGeo = new THREE.CylinderGeometry(0.43, 0.43, 1.5, 32);
        const waterMat = new THREE.MeshPhongMaterial({ color: 0x3399ff, emissive: 0x002244, transparent: true, opacity: 0.8 });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.y = -0.75; // –¥–Ω–æ
        water.scale.set(1, 0.01, 1); // –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Ä—ñ–≤–µ–Ω—å
        water.castShadow = true;
        water.receiveShadow = true;
        gaugeGroup.add(water);

        // –®–∫–∞–ª–∞ (–º—ñ—Ä–Ω—ñ –ø–æ–∑–Ω–∞—á–∫–∏)
        for(let i = 1; i <= 5; i++) {
            const markGeo = new THREE.BoxGeometry(0.25, 0.03, 0.1);
            const markMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x333333 });
            const mark = new THREE.Mesh(markGeo, markMat);
            mark.position.set(0.5, -0.75 + i * 0.32, 0);
            gaugeGroup.add(mark);
            
            // –º–∞–ª–µ–Ω—å–∫–∞ —Ü–∏—Ñ—Ä–∞ (—ñ–º—ñ—Ç–∞—Ü—ñ—è)
            const numGeo = new THREE.BoxGeometry(0.1, 0.1, 0.05);
            const numMat = new THREE.MeshStandardMaterial({ color: 0xffffaa });
            const num = new THREE.Mesh(numGeo, numMat);
            num.position.set(0.55, -0.75 + i * 0.32, 0.1);
            gaugeGroup.add(num);
        }

        // –ú–µ—Ç–∞–ª–µ–≤–∏–π –æ–±—ñ–¥–æ–∫
        const rimGeo = new THREE.TorusGeometry(0.45, 0.05, 16, 50);
        const rimMat = new THREE.MeshStandardMaterial({ color: 0xccccdd, emissive: 0x224466 });
        const rim = new THREE.Mesh(rimGeo, rimMat);
        rim.rotation.x = Math.PI / 2;
        rim.position.y = 0.8;
        gaugeGroup.add(rim);

        // --- –°–ò–°–¢–ï–ú–ê –î–û–©–£ (–∫—Ä–∞–ø–ª—ñ –≤–µ–ª–∏–∫—ñ —Ç–∞ –æ–±'—î–º–Ω—ñ) ---
        const rainCount = 200; // –º–µ–Ω—à–µ, –∞–ª–µ –∫—Ä—É–ø–Ω—ñ—à—ñ
        const rainDrops = [];

        // –§—É–Ω–∫—Ü—ñ—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–±'—î–º–Ω–æ—ó –∫—Ä–∞–ø–ª—ñ (–≥—Ä—É–ø–∞: —Å—Ñ–µ—Ä–∞ + –∫–æ–Ω—É—Å)
        function createVolumetricDrop() {
            const group = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–Ω–µ —Ç—ñ–ª–æ (—Å—Ñ–µ—Ä–∞)
            const sphereGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const sphereMat = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                emissive: 0x113355,
                shininess: 60,
                transparent: true,
                opacity: 0.95
            });
            const sphere = new THREE.Mesh(sphereGeo, sphereMat);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            sphere.position.y = 0;
            group.add(sphere);

            // –•–≤–æ—Å—Ç–∏–∫ (–∫–æ–Ω—É—Å)
            const tailGeo = new THREE.ConeGeometry(0.06, 0.18, 5);
            const tailMat = new THREE.MeshPhongMaterial({ color: 0xaaccff, emissive: 0x113355 });
            const tail = new THREE.Mesh(tailGeo, tailMat);
            tail.castShadow = true;
            tail.position.y = -0.15;
            tail.rotation.x = 0.2; // —Ç—Ä–æ—Ö–∏ –Ω–∞—Ö–∏–ª—É
            group.add(tail);

            // –ë–ª–∏—Å–∫ (–º–∞–ª–µ–Ω—å–∫–∞ —Å—Ñ–µ—Ä–∞)
            const sparkGeo = new THREE.SphereGeometry(0.04, 4);
            const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const spark = new THREE.Mesh(sparkGeo, sparkMat);
            spark.position.set(0.05, 0.05, 0.08);
            group.add(spark);

            return group;
        }

        // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∫—Ä–∞–ø–µ–ª—å
        for (let i = 0; i < rainCount; i++) {
            const dropGroup = createVolumetricDrop();
            // –ü–æ—á–∞—Ç–∫–æ–≤–µ –ø–æ–ª–æ–∂–µ–Ω–Ω—è
            dropGroup.position.set(
                (Math.random() - 0.5) * 12,
                8 + Math.random() * 12,
                (Math.random() - 0.5) * 8
            );
            scene.add(dropGroup);
            
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –¥–∞–Ω—ñ: mesh (group), —à–≤–∏–¥–∫—ñ—Å—Ç—å (–≤–µ–∫—Ç–æ—Ä), –ø–æ–ø–µ—Ä–µ–¥–Ω—î –ø–æ–ª–æ–∂–µ–Ω–Ω—è, —Å—Ç–∞–Ω
            rainDrops.push({
                group: dropGroup,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.8,   // –Ω–µ–≤–µ–ª–∏–∫–∏–π –≤—ñ—Ç–µ—Ä
                    -2.5 - Math.random() * 1.5,    // —à–≤–∏–¥–∫—ñ—Å—Ç—å –ø–∞–¥—ñ–Ω–Ω—è
                    (Math.random() - 0.5) * 0.8
                ),
                prevPos: dropGroup.position.clone()
            });
        }

        // --- –Ü–ù–î–ò–ö–ê–¢–û–† –î–û–õ–û–ù–Ü (–≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–æ–Ω–∏ –≤–∑–∞—î–º–æ–¥—ñ—ó) ---
        const handSphereGeo = new THREE.SphereGeometry(0.6, 16);
        const handSphereMat = new THREE.MeshPhongMaterial({ 
            color: 0xffaa33, 
            emissive: 0x442200,
            transparent: true, 
            opacity: 0.3,
            wireframe: true
        });
        const handIndicator = new THREE.Mesh(handSphereGeo, handSphereMat);
        scene.add(handIndicator);
        handIndicator.visible = false; // –ø–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Ä—É–∫–∞ –≤ –∫–∞–¥—Ä—ñ

        // --- –¢–†–ï–ö–Ü–ù–ì –†–£–ö–ò ---
        let handPos = null; // {x, y, z}
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 1, 
            minDetectionConfidence: 0.6, 
            minTrackingConfidence: 0.6 
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0][9]; // –¶–µ–Ω—Ç—Ä –¥–æ–ª–æ–Ω—ñ
                // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —É –ø—Ä–æ—Å—Ç—ñ—Ä three.js (–ø—Ä–∏–±–ª–∏–∑–Ω–æ)
                handPos = {
                    x: (lm.x - 0.5) * 14,      // —à–∏—Ä—à–∏–π –¥—ñ–∞–ø–∞–∑–æ–Ω
                    y: -(lm.y - 0.5) * 10,
                    z: (lm.z * 8) - 2           // –≥–ª–∏–±–∏–Ω–∞
                };
                handIndicator.position.set(handPos.x, handPos.y, handPos.z);
                handIndicator.visible = true;
            } else {
                handPos = null;
                handIndicator.visible = false;
            }
        });

        // --- –ö–∞–º–µ—Ä–∞ MediaPipe ---
        async function startGame() {
            overlay.style.display = 'none';
            gameActive = true;
            collectedDrops = 0;
            timeLeft = 60;
            updateUI();
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 1280,
                height: 720
            });
            cameraUtils.start();
            
            // –¢–∞–π–º–µ—Ä
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(() => {
                if (!gameActive) return;
                timeLeft -= 1;
                updateUI();
                if (timeLeft <= 0) {
                    gameActive = false;
                    timerDiv.classList.add('warning');
                    clearInterval(gameInterval);
                }
            }, 1000);
            
            animate();
        }

        function updateUI() {
            collectedSpan.innerHTML = collectedDrops + ' <small>/ 60 —Å–µ–∫</small>';
            const mins = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            timerDiv.textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
            if (timeLeft <= 10) timerDiv.classList.add('warning');
            else timerDiv.classList.remove('warning');
        }

        // --- –§–Ü–ó–ò–ö–ê –¢–ê –ê–ù–Ü–ú–ê–¶–Ü–Ø ---
        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1); // –æ–±–º–µ–∂–µ–Ω–Ω—è

            if (!gameActive) {
                // –ü—Ä–æ—Å—Ç–æ –∞–Ω—ñ–º—É—î–º–æ –ø–∞–¥—ñ–Ω–Ω—è –±–µ–∑ –∑–±–æ—Ä—É (–∞–±–æ –º–æ–∂–Ω–∞ –∑—É–ø–∏–Ω–∏—Ç–∏)
                renderer.render(scene, camera);
                return;
            }

            // –î–æ—â–æ–º—ñ—Ä —Å–ª—ñ–¥—É—î –∑–∞ —Ä—É–∫–æ—é –ø–ª–∞–≤–Ω–æ
            if (handPos) {
                gaugeGroup.position.lerp(new THREE.Vector3(handPos.x, handPos.y, 0), 0.15);
            }

            // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–∂–Ω–æ—ó –∫—Ä–∞–ø–ª—ñ
            rainDrops.forEach(drop => {
                const group = drop.group;
                const vel = drop.velocity;
                
                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—î –ø–æ–ª–æ–∂–µ–Ω–Ω—è
                drop.prevPos.copy(group.position);
                
                // –†—É—Ö —ñ–∑ –≤—ñ—Ç—Ä–æ–º —Ç–∞ –≥—Ä–∞–≤—ñ—Ç–∞—Ü—ñ—î—é
                vel.y += delta * 4.0; // –≥—Ä–∞–≤—ñ—Ç–∞—Ü—ñ—è –ø—Ä–∏—Å–∫–æ—Ä—é—î –ø–∞–¥—ñ–Ω–Ω—è
                group.position.x += vel.x * delta * 3;
                group.position.y += vel.y * delta * 3;
                group.position.z += vel.z * delta * 3;

                // –û–±–µ—Ä—Ç–∞–Ω–Ω—è –∫—Ä–∞–ø–ª—ñ –¥–ª—è –µ—Ñ–µ–∫—Ç—É –ø–æ–ª—å–æ—Ç—É
                group.rotation.x += 0.02;
                group.rotation.z += 0.03;

                // --- –ö–û–õ–Ü–ó–Ü–á –ó –†–£–ö–û–Æ ---
                if (handPos) {
                    const handRadius = 0.7;
                    const toHand = new THREE.Vector3(
                        group.position.x - handPos.x,
                        group.position.y - handPos.y,
                        group.position.z - handPos.z
                    );
                    const distToHand = toHand.length();
                    if (distToHand < handRadius) {
                        // –í—ñ–¥—à—Ç–æ–≤—Ö—É–≤–∞–Ω–Ω—è (–ø—Ä–æ—Å—Ç–∏–π –≤—ñ–¥—Å–∫–æ–∫)
                        const normal = toHand.clone().normalize();
                        // –í—ñ–¥–±–∏–≤–∞—î–º–æ —à–≤–∏–¥–∫—ñ—Å—Ç—å –≤—ñ–¥–Ω–æ—Å–Ω–æ –Ω–æ—Ä–º–∞–ª—ñ
                        const dot = vel.dot(normal);
                        if (dot < 0) { // —Ä—É—Ö —É –Ω–∞–ø—Ä—è–º–∫—É —Ä—É–∫–∏
                            vel.addScaledVector(normal, -2 * dot).multiplyScalar(0.7); // –∫–æ–µ—Ñ. –≤—ñ–¥—Å–∫–æ–∫—É
                        }
                        // –í—ñ–¥—Å—É–≤–∞—î–º–æ –∫—Ä–∞–ø–ª—é –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω—é
                        group.position.copy(handPos).add(normal.multiplyScalar(handRadius + 0.1));
                    }
                }

                // --- –ö–û–õ–Ü–ó–Ü–á –ó –î–û–©–û–ú–Ü–†–û–ú ---
                const gaugePos = gaugeGroup.position;
                const localPos = new THREE.Vector3().subVectors(group.position, gaugePos);
                
                // –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ü–∏–ª—ñ–Ω–¥—Ä–∞
                const radius = 0.5;      // —Ç—Ä–æ—Ö–∏ –±—ñ–ª—å—à–µ –∑–∞ —Å–∫–ª–æ
                const halfHeight = 0.9;   // –≤–∏—Å–æ—Ç–∞ –ø–æ–ª–æ–≤–∏–Ω–∏

                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –∑—ñ—Ç–∫–Ω–µ–Ω–Ω—è –∑ –±–æ–∫–æ–≤–æ—é —Å—Ç—ñ–Ω–∫–æ—é
                const inCylinderXZ = Math.sqrt(localPos.x*localPos.x + localPos.z*localPos.z);
                const inYRange = Math.abs(localPos.y) < halfHeight;

                if (inYRange && inCylinderXZ > radius - 0.15 && inCylinderXZ < radius + 0.15) {
                    // –í—ñ–¥—Å–∫–æ–∫ –≤—ñ–¥ –±—ñ—á–Ω–æ—ó –ø–æ–≤–µ—Ä—Ö–Ω—ñ
                    const radialDir = new THREE.Vector3(localPos.x, 0, localPos.z).normalize();
                    const radialVel = vel.clone().dot(radialDir);
                    if (radialVel > 0) { // —Ä—É—Ö –Ω–∞–∑–æ–≤–Ω—ñ? –Ω—ñ, –º–∏ —Ö–æ—á–µ–º–æ –≤—ñ–¥–±–∏–≤–∞—Ç–∏ –≤—Å–µ—Ä–µ–¥–∏–Ω—É
                        // –≤—ñ–¥–±–∏–≤–∞—î–º–æ —Ä–∞–¥—ñ–∞–ª—å–Ω—É –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É
                        vel.addScaledVector(radialDir, -2 * radialVel * 0.5); // –ø–æ–º'—è–∫—à–µ–Ω–Ω—è
                    }
                    // –¢—Ä–æ—Ö–∏ –≤—ñ–¥—à—Ç–æ–≤—Ö–Ω—É—Ç–∏
                    group.position.copy(gaugePos.clone().add(radialDir.multiplyScalar(radius + 0.2)));
                }

                // --- –ó–ë–Ü–† –ö–†–ê–ü–õ–Ü (—á–µ—Ä–µ–∑ –≤–µ—Ä—Ö) ---
                // –Ø–∫—â–æ –∫—Ä–∞–ø–ª—è –≤ –º–µ–∂–∞—Ö —Ä–∞–¥—ñ—É—Å–∞ –≤–µ—Ä—Ö–Ω—å–æ–≥–æ –æ—Ç–≤–æ—Ä—É —ñ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –∑–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
                const atTop = (localPos.y > halfHeight - 0.2 && localPos.y < halfHeight + 0.3);
                const withinRadius = Math.sqrt(localPos.x*localPos.x + localPos.z*localPos.z) < radius - 0.1;
                
                if (atTop && withinRadius && vel.y < 0) {
                    // –ü–µ—Ä–µ–≤—ñ—Ä–∏–º–æ, —á–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—î –ø–æ–ª–æ–∂–µ–Ω–Ω—è –±—É–ª–æ –≤–∏—â–µ
                    const prevLocalY = drop.prevPos.y - gaugePos.y;
                    if (prevLocalY > halfHeight) {
                        // –ó–∞—Ä–∞—Ö–æ–≤—É—î–º–æ –∑–±—ñ—Ä
                        if (gameActive) {
                            collectedDrops++;
                            updateUI();
                            
                            // –í—ñ–∑—É–∞–ª—å–Ω–∏–π –µ—Ñ–µ–∫—Ç: –ø—ñ–¥–Ω—ñ–º–∞—î–º–æ —Ä—ñ–≤–µ–Ω—å –≤–æ–¥–∏ —Ç—Ä–æ—Ö–∏
                            const visualScale = Math.min(collectedDrops / 60, 1.0); // –º–∞–∫—Å–∏–º—É–º 60 –∫—Ä–∞–ø–µ–ª—å = –ø–æ–≤–Ω–∞ —à–∫–∞–ª–∞
                            water.scale.y = visualScale;
                            water.position.y = -0.75 + (0.75 * visualScale);
                        }
                        
                        // "–ó–±–∏—Ä–∞—î–º–æ" –∫—Ä–∞–ø–ª—é: –ø–µ—Ä–µ–∫–∏–¥–∞—î–º–æ –Ω–∞–≥–æ—Ä—É
                        group.position.set(
                            (Math.random() - 0.5) * 10,
                            10 + Math.random() * 8,
                            (Math.random() - 0.5) * 8
                        );
                        vel.set(
                            (Math.random() - 0.5) * 0.8,
                            -2.0 - Math.random() * 1.5,
                            (Math.random() - 0.5) * 0.8
                        );
                        return; // –Ω–∞—Å—Ç—É–ø–Ω–∞ –∫—Ä–∞–ø–ª—è
                    }
                }

                // –Ø–∫—â–æ –∫—Ä–∞–ø–ª—è –≤–ø–∞–ª–∞ –Ω–∞–¥—Ç–æ –Ω–∏–∑—å–∫–æ - –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–∏
                if (group.position.y < -6) {
                    group.position.set(
                        (Math.random() - 0.5) * 12,
                        12 + Math.random() * 10,
                        (Math.random() - 0.5) * 8
                    );
                    vel.set(
                        (Math.random() - 0.5) * 0.8,
                        -2.0 - Math.random() * 1.5,
                        (Math.random() - 0.5) * 0.8
                    );
                }
            });

            // –ó–º—É—Å–∏—Ç–∏ –∫–∞–º–µ—Ä—É —Ç—Ä–æ—Ö–∏ —Å—Ç–µ–∂–∏—Ç–∏ –∑–∞ –¥–æ—â–æ–º—ñ—Ä–æ–º
            if (handPos) {
                const targetCamPos = new THREE.Vector3(handPos.x * 0.3, 1.5, 8);
                camera.position.lerp(targetCamPos, 0.05);
                camera.lookAt(gaugeGroup.position.clone().add(new THREE.Vector3(0, 0.5, 0)));
            } else {
                camera.lookAt(gaugeGroup.position.clone().add(new THREE.Vector3(0, 0.5, 0)));
            }

            renderer.render(scene, camera);
        }

        // –ê–¥–∞–ø—Ç–∞—Ü—ñ—è –ø—ñ–¥ —Ä–æ–∑–º—ñ—Ä –≤—ñ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // –î–æ–¥–∞–º–æ –∑—ñ—Ä–æ—á–∫–∏ –∞–±–æ —Ö–º–∞—Ä–∏ –¥–ª—è —Ñ–æ–Ω—É (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ)
        function addStars() {
            const starsGeo = new THREE.BufferGeometry();
            const starsCount = 300;
            const positions = new Float32Array(starsCount * 3);
            for (let i = 0; i < starsCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i+1] = (Math.random() - 0.5) * 50;
                positions[i+2] = (Math.random() - 0.5) * 100 - 30;
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starsMat = new THREE.PointsMaterial({ color: 0x88aaff, size: 0.15 });
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);
        }
        addStars();

        // –ü–æ—á–∞—Ç–∫–æ–≤–µ –ø—Ä–∏—Ö–æ–≤–∞–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ (–æ—á—ñ–∫—É–≤–∞–Ω–Ω—è —Å—Ç–∞—Ä—Ç—É)
        // –ê–ª–µ —Å—Ü–µ–Ω–∞ –±—É–¥–µ –ø—Ä–æ—Å—Ç–æ —Ñ–æ–Ω
        animate(); // –∑–∞–ø—É—Å–∫–∞—î–º–æ –∞–Ω—ñ–º–∞—Ü—ñ—é –Ω–∞–≤—ñ—Ç—å –¥–æ —Å—Ç–∞—Ä—Ç—É, –∞–ª–µ –±–µ–∑ –∞–∫—Ç–∏–≤–Ω–æ—ó –≥—Ä–∏
    </script>
</body>
</html>
